<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MVP: Queue Polling Performance Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }
        .metric-card { border: 1px solid #ddd; padding: 15px; border-radius: 4px; text-align: center; }
        .metric-value { font-size: 24px; font-weight: bold; color: #007bff; }
        .test-section { border: 1px solid #ddd; padding: 15px; margin: 15px 0; }
        .log { background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>MVP: Azure Queue Polling Performance Test</h1>
        <p><strong>Purpose:</strong> Analyze performance implications of browser-based queue polling</p>
        
        <div class="test-section">
            <h3>Performance Metrics</h3>
            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="poll-count">0</div>
                    <div>Poll Requests</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="battery-impact">0%</div>
                    <div>Battery Impact</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="network-usage">0 KB</div>
                    <div>Network Usage</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="success-rate">0%</div>
                    <div>Success Rate</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>Queue Polling Simulation</h3>
            <label>
                Poll Interval: 
                <select id="poll-interval">
                    <option value="5000">5 seconds</option>
                    <option value="10000">10 seconds</option>
                    <option value="30000">30 seconds</option>
                    <option value="60000" selected>60 seconds</option>
                </select>
            </label>
            <br><br>
            <button onclick="startPolling()" id="start-btn">Start Polling</button>
            <button onclick="stopPolling()" id="stop-btn" disabled>Stop Polling</button>
            <button onclick="resetMetrics()">Reset Metrics</button>
        </div>

        <div class="test-section">
            <h3>Performance Analysis</h3>
            <div id="analysis-result"></div>
        </div>

        <div class="test-section">
            <h3>Activity Log</h3>
            <div id="activity-log" class="log"></div>
        </div>
    </div>

    <script>
        let pollingInterval = null;
        let metrics = {
            pollCount: 0,
            successCount: 0,
            networkBytes: 0,
            startTime: null,
            batteryImpact: 0
        };

        function log(message) {
            const logDiv = document.getElementById('activity-log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateMetrics() {
            document.getElementById('poll-count').textContent = metrics.pollCount;
            document.getElementById('success-rate').textContent = 
                metrics.pollCount > 0 ? Math.round((metrics.successCount / metrics.pollCount) * 100) + '%' : '0%';
            document.getElementById('network-usage').textContent = 
                (metrics.networkBytes / 1024).toFixed(1) + ' KB';
            
            // Estimate battery impact based on polling frequency
            const interval = parseInt(document.getElementById('poll-interval').value);
            const pollsPerHour = 3600000 / interval;
            metrics.batteryImpact = Math.min(pollsPerHour * 0.1, 100); // Rough estimate
            document.getElementById('battery-impact').textContent = metrics.batteryImpact.toFixed(1) + '%';
        }

        function simulateQueuePoll() {
            metrics.pollCount++;
            
            // Simulate network request
            const requestSize = 150; // bytes for typical queue poll request
            const responseSize = Math.random() > 0.8 ? 300 : 50; // 20% chance of message
            metrics.networkBytes += requestSize + responseSize;
            
            // Simulate response
            const hasMessage = Math.random() > 0.9; // 10% chance of new message
            
            if (hasMessage) {
                metrics.successCount++;
                log(`üì® New payment status update received (${responseSize} bytes)`);
                
                // Simulate payment status update
                const statuses = ['processing', 'completed', 'failed'];
                const status = statuses[Math.floor(Math.random() * statuses.length)];
                log(`üí≥ Payment status changed to: ${status}`);
            } else {
                log(`‚≠ï No new messages (${responseSize} bytes)`);
            }
            
            updateMetrics();
            analyzePerformance();
        }

        function startPolling() {
            if (pollingInterval) return;
            
            const interval = parseInt(document.getElementById('poll-interval').value);
            metrics.startTime = Date.now();
            
            log(`üöÄ Starting queue polling every ${interval/1000} seconds`);
            
            pollingInterval = setInterval(simulateQueuePoll, interval);
            
            document.getElementById('start-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
        }

        function stopPolling() {
            if (!pollingInterval) return;
            
            clearInterval(pollingInterval);
            pollingInterval = null;
            
            log(`‚èπÔ∏è Queue polling stopped`);
            
            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
        }

        function resetMetrics() {
            stopPolling();
            metrics = {
                pollCount: 0,
                successCount: 0,
                networkBytes: 0,
                startTime: null,
                batteryImpact: 0
            };
            updateMetrics();
            document.getElementById('activity-log').innerHTML = '';
            document.getElementById('analysis-result').innerHTML = '';
            log('üìä Metrics reset');
        }

        function analyzePerformance() {
            const interval = parseInt(document.getElementById('poll-interval').value);
            const runtime = metrics.startTime ? (Date.now() - metrics.startTime) / 1000 : 0;
            
            const analysis = {
                efficiency: metrics.successCount / Math.max(metrics.pollCount, 1),
                networkEfficiency: metrics.networkBytes / Math.max(metrics.pollCount, 1),
                batteryDrain: metrics.batteryImpact,
                recommendations: []
            };
            
            // Generate recommendations
            if (analysis.efficiency < 0.2) {
                analysis.recommendations.push('‚ùå Low efficiency: Consider WebSocket or Server-Sent Events');
            }
            if (analysis.batteryDrain > 5) {
                analysis.recommendations.push('üîã High battery impact: Increase polling interval');
            }
            if (analysis.networkEfficiency > 200) {
                analysis.recommendations.push('üì° High network usage: Implement exponential backoff');
            }
            if (interval < 30000) {
                analysis.recommendations.push('‚è±Ô∏è Frequent polling: Consider push notifications');
            }
            
            // Mobile-specific issues
            analysis.recommendations.push('üì± Mobile issues: Background tab throttling, battery optimization');
            analysis.recommendations.push('üåê Network issues: Cellular data usage, connection drops');
            
            const resultDiv = document.getElementById('analysis-result');
            const efficiencyColor = analysis.efficiency > 0.5 ? 'success' : 
                                   analysis.efficiency > 0.2 ? 'warning' : 'error';
            
            resultDiv.innerHTML = `
                <div class="status ${efficiencyColor}">
                    <strong>üìä Performance Analysis (${runtime.toFixed(0)}s runtime)</strong><br><br>
                    <strong>Efficiency:</strong> ${(analysis.efficiency * 100).toFixed(1)}% (${metrics.successCount}/${metrics.pollCount} useful responses)<br>
                    <strong>Avg Network per Poll:</strong> ${analysis.networkEfficiency.toFixed(0)} bytes<br>
                    <strong>Estimated Battery Impact:</strong> ${analysis.batteryDrain.toFixed(1)}% per hour<br><br>
                    <strong>üîß Recommendations:</strong><br>
                    ${analysis.recommendations.map(r => `‚Ä¢ ${r}`).join('<br>')}
                </div>
            `;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('üéØ Queue polling performance test initialized');
            updateMetrics();
        });

        // Detect page visibility changes (mobile optimization)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                log('üëÅÔ∏è Page hidden - polling may be throttled by browser');
            } else {
                log('üëÅÔ∏è Page visible - polling resumed');
            }
        });
    </script>
</body>
</html>
