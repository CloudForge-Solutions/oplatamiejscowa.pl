# üß™ Integration Testing Plan - Secure Payment Flow

## üìã **FLOW VALIDATION CHECKLIST**

### **‚úÖ CURRENT IMPLEMENTATION STATUS**

**COMPLETED:**
- ‚úÖ **Frontend Route**: `/p/:reservationId` exists and working
- ‚úÖ **Secure BlobStorageService**: API-first approach implemented
- ‚úÖ **API SAS Token Generation**: Blob-specific tokens with validation
- ‚úÖ **UUID Validation**: Rate-limited API endpoint
- ‚úÖ **Reservation Validation**: API checks blob existence before SAS generation
- ‚úÖ **Rate Limiting**: Prevents UUID scanning attacks
- ‚úÖ **imoje Integration**: Backend service ready

**NEEDS TESTING:**
- üß™ **End-to-end flow**: URL ‚Üí SAS token ‚Üí blob access ‚Üí payment status
- üß™ **Error handling**: Invalid UUIDs, missing reservations, expired tokens
- üß™ **Security**: Rate limiting, token expiry, blob-specific access
- üß™ **Performance**: Direct blob access vs API calls

---

## üéØ **TESTING SCENARIOS**

### **Scenario 1: Happy Path - Valid Reservation**
```bash
# 1. User opens payment URL
curl -X GET "http://localhost:3040/p/735bc981-a729-49a3-9642-84468e0cd3e1"

# 2. App requests SAS token (automatic)
curl -X POST "http://localhost:3044/api/storage/sas-tokens" \
  -H "Content-Type: application/json" \
  -d '{
    "containerName": "reservations",
    "reservationId": "735bc981-a729-49a3-9642-84468e0cd3e1",
    "permissions": "r",
    "expiryHours": 24
  }'

# 3. App uses SAS token to access blob (automatic)
# Direct blob access: https://devstoreaccount1.blob.core.windows.net/reservations/reservations/735bc981-a729-49a3-9642-84468e0cd3e1.json?{SAS_TOKEN}
```

### **Scenario 2: Security Test - Invalid UUID**
```bash
# Should return 400 Bad Request
curl -X POST "http://localhost:3044/api/storage/sas-tokens" \
  -H "Content-Type: application/json" \
  -d '{
    "containerName": "reservations",
    "reservationId": "invalid-uuid",
    "permissions": "r"
  }'
```

### **Scenario 3: Security Test - Non-existent Reservation**
```bash
# Should return 404 Not Found
curl -X POST "http://localhost:3044/api/storage/sas-tokens" \
  -H "Content-Type: application/json" \
  -d '{
    "containerName": "reservations",
    "reservationId": "123e4567-e89b-12d3-a456-426614174000",
    "permissions": "r"
  }'
```

### **Scenario 4: Rate Limiting Test**
```bash
# Rapid requests should trigger rate limiting
for i in {1..70}; do
  curl -X POST "http://localhost:3044/api/storage/sas-tokens" \
    -H "Content-Type: application/json" \
    -d '{"reservationId": "test-uuid-'$i'"}' &
done
wait
```

---

## üîß **MANUAL TESTING STEPS**

### **Step 1: Create Test Reservation**
```bash
# Create a test reservation via API
curl -X POST "http://localhost:3044/api/reservations" \
  -H "Content-Type: application/json" \
  -d '{
    "guestName": "Test User",
    "guestEmail": "test@example.com",
    "accommodationName": "Test Hotel",
    "accommodationAddress": "Test Address",
    "checkInDate": "2025-08-15",
    "checkOutDate": "2025-08-17",
    "numberOfGuests": 2,
    "numberOfNights": 2,
    "taxAmountPerNight": 2.50,
    "totalTaxAmount": 10.00,
    "currency": "PLN",
    "cityName": "Krak√≥w"
  }'
```

### **Step 2: Test Frontend Flow**
1. **Open browser**: `http://localhost:3040/p/{RESERVATION_ID}`
2. **Check network tab**: Verify SAS token request
3. **Check console**: Verify blob access logs
4. **Verify data**: Reservation details displayed correctly

### **Step 3: Test Payment Integration**
1. **Click payment button**: Should redirect to imoje
2. **Complete payment**: Use imoje sandbox
3. **Return to app**: Verify status update
4. **Check polling**: Verify status updates from blob

---

## üìä **PERFORMANCE BENCHMARKS**

### **Cost Comparison (per 1000 requests)**

**OLD APPROACH (API-heavy):**
- API calls for reservation data: ~$0.50
- API calls for payment status: ~$0.30
- Database queries: ~$0.20
- **Total**: ~$1.00

**NEW APPROACH (blob-direct):**
- SAS token generation: ~$0.05
- Direct blob access: ~$0.02
- No database queries: $0.00
- **Total**: ~$0.07

**üí∞ COST SAVINGS: 93% reduction**

### **Latency Comparison**

**OLD APPROACH:**
- API ‚Üí Database ‚Üí Response: ~200-500ms
- Multiple API calls: ~1-2 seconds total

**NEW APPROACH:**
- SAS token request: ~50-100ms
- Direct blob access: ~20-50ms
- **Total**: ~70-150ms

**‚ö° PERFORMANCE IMPROVEMENT: 60-80% faster**

---

## üõ°Ô∏è **SECURITY VALIDATION**

### **‚úÖ SECURITY FEATURES IMPLEMENTED**

1. **No Client-Side Credentials**: ‚úÖ All SAS tokens generated by API
2. **Blob-Specific Access**: ‚úÖ SAS tokens limited to specific reservation blob
3. **Time-Limited Tokens**: ‚úÖ 24-hour expiry maximum
4. **UUID Validation**: ‚úÖ API validates UUID format and existence
5. **Rate Limiting**: ‚úÖ Prevents UUID scanning attacks
6. **Read-Only Access**: ‚úÖ Default permissions are read-only
7. **Reservation Validation**: ‚úÖ API checks blob exists before SAS generation

### **üîí SECURITY TESTS TO PERFORM**

1. **Token Expiry**: Verify expired tokens are rejected
2. **Invalid UUIDs**: Verify malformed UUIDs are rejected
3. **Non-existent Reservations**: Verify 404 responses
4. **Rate Limiting**: Verify excessive requests are blocked
5. **Cross-Blob Access**: Verify SAS token only works for specific blob
6. **Permission Escalation**: Verify read-only tokens can't write

---

## üéâ **SUCCESS CRITERIA**

### **‚úÖ FUNCTIONAL REQUIREMENTS**
- [ ] User can open payment URL with valid UUID
- [ ] App successfully requests and receives SAS token
- [ ] App can access reservation data directly from blob
- [ ] Payment flow works end-to-end with imoje
- [ ] Status updates work via blob polling

### **‚úÖ SECURITY REQUIREMENTS**
- [ ] Invalid UUIDs are rejected with proper error messages
- [ ] Non-existent reservations return 404
- [ ] Rate limiting prevents abuse
- [ ] SAS tokens expire after 24 hours
- [ ] Blob access is limited to specific reservation

### **‚úÖ PERFORMANCE REQUIREMENTS**
- [ ] Initial page load < 2 seconds
- [ ] SAS token generation < 100ms
- [ ] Direct blob access < 50ms
- [ ] 93% cost reduction achieved
- [ ] 60%+ latency improvement achieved

---

## üöÄ **NEXT STEPS**

1. **Run Integration Tests**: Execute all test scenarios
2. **Performance Benchmarking**: Measure actual vs expected performance
3. **Security Audit**: Verify all security measures work
4. **Load Testing**: Test with multiple concurrent users
5. **Production Readiness**: Deploy to staging environment
