/**
 * BlobStorageService - Secure Azure Blob Storage integration for Tourist Tax Application
 *
 * RESPONSIBILITY: Handle secure blob access using API-generated SAS tokens
 * ARCHITECTURE: API-first approach with blob-specific SAS tokens for security
 * SECURITY: No client-side credentials - all SAS tokens generated by backend API
 */

// Browser-compatible Azure Storage imports
import { BlobServiceClient, BlobClient } from '@azure/storage-blob';
import { logger } from '../CentralizedLogger';

export interface ReservationData {
  id: string;
  guestName: string;
  guestEmail: string;
  accommodationName: string;
  accommodationAddress: string;
  checkInDate: string;
  checkOutDate: string;
  numberOfGuests: number;
  numberOfNights: number;
  taxAmountPerNight: number;
  totalTaxAmount: number;
  currency: string;
  status: 'pending' | 'paid' | 'failed' | 'cancelled';
  createdAt: string;
  updatedAt: string;
  paymentId?: string;
  paymentUrl?: string;
}

export interface BlobStorageConfig {
  apiBaseUrl: string;
  containerName: string;
}

export interface SasTokenResponse {
  success: boolean;
  sasToken: string;
  serviceUrl: string;
  expiresAt: string;
}

/**
 * SecureBlobStorageService - API-first Azure Storage integration
 *
 * SECURITY: Uses API-generated SAS tokens instead of client-side credentials
 * COST-OPTIMIZED: Direct blob access after SAS token acquisition
 */
export class BlobStorageService {
  private config: BlobStorageConfig;
  private sasTokenCache: Map<string, { token: SasTokenResponse; expiresAt: Date }> = new Map();

  constructor(config: BlobStorageConfig) {
    this.config = config;

    logger.info('üóÑÔ∏è SecureBlobStorageService initialized', {
      apiBaseUrl: config.apiBaseUrl,
      containerName: config.containerName,
      authMethod: 'API-Generated SAS Tokens'
    });
  }



  /**
   * Request SAS token from API for specific reservation blob
   * SECURITY: UUID validation and rate limiting handled by API
   */
  private async requestSasToken(reservationId: string): Promise<SasTokenResponse> {
    try {
      logger.info('üîê Requesting SAS token from API', { reservationId });

      const response = await fetch(`${this.config.apiBaseUrl}/api/storage/sas-tokens`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          containerName: this.config.containerName,
          reservationId: reservationId,
          permissions: 'r', // Read-only for security
          expiryHours: 24
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API request failed: ${response.status} ${errorText}`);
      }

      const sasTokenResponse: SasTokenResponse = await response.json();

      if (!sasTokenResponse.success) {
        throw new Error('SAS token generation failed');
      }

      logger.info('‚úÖ SAS token received from API', {
        reservationId,
        expiresAt: sasTokenResponse.expiresAt
      });

      return sasTokenResponse;
    } catch (error) {
      logger.error('‚ùå Failed to request SAS token from API', {
        error: error instanceof Error ? error.message : 'Unknown error',
        reservationId
      });
      throw error;
    }
  }

  /**
   * Get cached or request new SAS token for reservation
   */
  private async getSasToken(reservationId: string): Promise<SasTokenResponse> {
    const cacheKey = `${this.config.containerName}:${reservationId}`;
    const cached = this.sasTokenCache.get(cacheKey);

    // Check if cached token is still valid (with 5 minute buffer)
    if (cached && cached.expiresAt.getTime() > Date.now() + 5 * 60 * 1000) {
      logger.debug('üîÑ Using cached SAS token', { reservationId });
      return cached.token;
    }

    // Request new token from API
    const token = await this.requestSasToken(reservationId);

    // Cache the token
    this.sasTokenCache.set(cacheKey, {
      token,
      expiresAt: new Date(token.expiresAt)
    });

    return token;
  }

  /**
   * Poll reservation data for payment status updates
   * OPTIMIZED: Direct blob access for real-time status polling
   */
  async pollReservationStatus(reservationId: string): Promise<ReservationData | null> {
    // Use the same secure getReservation method for polling
    return this.getReservation(reservationId);
  }

  /**
   * Retrieve reservation data using secure API-generated SAS token
   * SECURITY: API validates UUID and generates blob-specific SAS token
   * COST-OPTIMIZED: Direct blob access after token acquisition
   */
  async getReservation(reservationId: string): Promise<ReservationData | null> {
    try {
      logger.info('üîç Retrieving reservation with secure SAS token', { reservationId });

      // Step 1: Get SAS token from API (includes UUID validation and rate limiting)
      const sasToken = await this.getSasToken(reservationId);

      // Step 2: Create blob client with SAS token for direct access
      const blobUrl = `${sasToken.serviceUrl}/${this.config.containerName}/${reservationId}.json?${sasToken.sasToken}`;
      const blobClient = new BlobClient(blobUrl);

      // Step 3: Check if blob exists
      const exists = await blobClient.exists();
      if (!exists) {
        logger.warn('‚ö†Ô∏è Reservation not found in blob storage', {
          reservationId,
          blobUrl: blobUrl.split('?')[0] // Log URL without SAS token
        });
        return null;
      }

      // Step 4: Download blob content directly
      const downloadResponse = await blobClient.download();
      const blobBody = await downloadResponse.blobBody;
      const content = await blobBody!.text();

      const reservationData: ReservationData = JSON.parse(content);

      logger.info('‚úÖ Reservation retrieved via secure SAS token', {
        reservationId,
        status: reservationData.status,
        directAccess: true
      });

      return reservationData;
    } catch (error) {
      logger.error('‚ùå Failed to retrieve reservation via secure SAS token', {
        error: error instanceof Error ? error.message : 'Unknown error',
        reservationId
      });
      return null;
    }
  }

  /**
   * Check if reservation exists (lightweight check via API)
   * OPTIMIZED: Uses API validation instead of direct blob access
   */
  async reservationExists(reservationId: string): Promise<boolean> {
    try {
      // This will validate UUID and check existence via API rate-limited endpoint
      const reservation = await this.getReservation(reservationId);
      return reservation !== null;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Failed to check reservation existence', {
        error: error instanceof Error ? error.message : 'Unknown error',
        reservationId
      });
      return false;
    }
  }

}

// Create singleton instance for the application with secure API-first configuration
const blobStorageConfig: BlobStorageConfig = {
  apiBaseUrl: import.meta.env['VITE_API_BASE_URL'] || 'http://localhost:3044',
  containerName: import.meta.env['VITE_CONTAINER_NAME'] || 'reservations'
};

export const blobStorageService = new BlobStorageService(blobStorageConfig);
